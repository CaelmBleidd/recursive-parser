import org.junit.Assert.fail
import org.junit.Test
import java.lang.RuntimeException
import java.text.ParseException
import kotlin.random.Random

class ParserTest {

    private val testsSpliterator = "=".repeat(150)
    private val n = 1e3.toInt()

    private val parser by lazy {
        Parser()
    }

    private fun getCorrectFirstCharacter(): Char {
        val chance = Random.nextInt(27)
        return if (chance == 0) {
            '_'
        } else {
            val letter = Random.nextInt(26)
            'a' + letter
        }
    }

    private fun getCorrectCharacter(): Char {
        return when (Random.nextInt(37)) {
            0 -> {
                '_'
            }
            in (1..27) -> {
                val letter = Random.nextInt(26)
                'a' + letter
            }
            else -> {
                val digit = Random.nextInt(10)
                '0' + digit
            }
        }
    }

    private fun getCorrectName(len: Int): String {
        var name = ""
        buildString {
            append(getCorrectFirstCharacter())
            for (i in 0 until len - 1) {
                append(getCorrectCharacter())
            }
            append('0')
            name = this.toString()
        }

        return name
    }

    private fun getType(): String {
        return arrayListOf("byte", "shortint", "integer", "word", "longint", "real", "single", "double", "extended").random()
    }

    private fun getVariables(): String {
        val blocks = arrayListOf<String>()
        for (i in 0..(1..10).random()) {
            buildString {
                for (j in 0..(1..10).random()) {
                    append(getCorrectName((1..4).random()))
                    append(", ")
                }
                append(getCorrectName((1..10).random()))
                append(": ")
                append(getType())
                blocks.add(this.toString())
            }
        }
        return blocks.joinToString("; ")
    }

    private fun correctDeclaration(): String {
        return buildString {
            val type = arrayListOf("function ", "procedure ").random()
            append(type)
            append(getCorrectName((1..10).random()))
            append("(")
            append(getVariables())
            append(")")
            if (type == "function ") {
                append(": ")
                append(getType()) // дописать типы
                append(";")
            } else {
                append(";")
            }
        }
    }

    private fun correctTest(
            testsNumber: Int = n
    ) {
        repeat(testsNumber) {
            val declaration = correctDeclaration()
            println(declaration)
            parser.parse(declaration)
        }
        println(testsSpliterator)
    }

    @Test
    fun correct_ManyBlocks_ManyVariables_ManyTypes() {
        correctTest((10..100).random())
    }

    @Test
    fun correctWithDraw() {
        val input = "function parse(a, b, c: integer; d, e, t: real) : real;"
        TreeDrawer().printToFile(parser.parse(input), "autoTest")
        Runtime.getRuntime().exec("dot -Tjpg autoTest.dot -o autoTest.jpg")
    }

    @Test
    fun currentWithDrawForAutogenerated() {
        val input = correctDeclaration()
        TreeDrawer().printToFile(parser.parse(input), "autoGeneratedTest")
        Runtime.getRuntime().exec("dot -Tjpg autoGeneratedTest.dot -o autoGeneratedTest.jpg")
    }

    @Test
    fun incorrect_NameIsKeyword() {
        println("Incorrect keyword")
        incorrectTest("functiomMuntion w (a, b: double): real;")
    }

    @Test
    fun wrongNameOfVariable() {
        println("Incorrect variable name")
        incorrectTest("function w(3: double): real;")
    }

    @Test
    fun missedSemicolon() {
        println("Missed semicolon")
        incorrectTest("function w(a, b: double b c: real): real;")
    }

    @Test
    fun missedComma() {
        println("Missed comma")
        incorrectTest("procedure w(a b: double);")
    }

    @Test
    fun missedName() {
        println("Missed function name")
        incorrectTest("procedure ();")
    }

    @Test
    fun missedBracket() {
        println("Missed lparen")
        incorrectTest("procudure w a, b: double);")
    }

    @Test
    fun missedLastSemicolon() {
        println("Missed the last semicolon")
        incorrectTest("procedure w(a, b: real)")
    }

    private fun incorrectTest(line: String) {
        line.also {
            try {
                parser.parse(it)
                fail(it)
            } catch (e: ParseException) {
                println(it)
            }
        }
        println(testsSpliterator)    }
}

